import numpy as np
import scipy.stats as stats
from sklearn.linear_model import LinearRegression

# Задача 1 Даны значения величины заработной платы заемщиков банка (zp) и значения их поведенческого кредитного скоринга (ks): 
zp = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])
ks = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])
# Используя математические операции, посчитать коэффициенты линейной регрессии, приняв за X заработную плату (то есть, zp - признак), 
# а за y - значения скорингового балла (то есть, ks - целевая переменная). 
# Произвести расчет как с использованием intercept, так и без.

n = len(ks)
b1 = (n * np.sum(zp * ks) - np.sum(zp) * np.sum(ks)) / (n * np.sum(zp**2) - np.sum(zp)**2)
b0 = np.mean(ks) - b1 * np.mean(zp)
print(f'Уравнение линейной регрессии: y = {b0} + {b1} * x')

model = LinearRegression()
zp = zp.reshape(-1, 1)
regres = model.fit(zp, ks)
print(regres.intercept_)
print(regres.coef_)

# Задача 2 Посчитать коэффициент линейной регрессии при заработной плате (zp), используя градиентный спуск (без intercept).

def mse_(B1, y = ks, x = zp, n = n):
    return np.sum((B1 * x - y)**2)/n

alpha = pow(2.74, -1)
B1 = 0.1

for i in range(20):
    B1 -= alpha * (2/n) * np.sum((B1 * zp- ks) * zp)
    print('B1 = {}'.format(B1))

# Задача 3 (Дополнительно) Произвести вычисления как в пункте 2, но с вычислением intercept. 
# Учесть, что изменение коэффициентов должно производиться на каждом шаге одновременно 
# (то есть изменение одного коэффициента не должно влиять на изменение другого во время одной итерации).